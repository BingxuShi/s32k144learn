Parsed function:SetSimClkoutDiv_TrustedCall.isra.0
Parsed function:SetScgHsrunDivslow_TrustedCall.isra.0
Parsed function:SetScgHsrunDivbus_TrustedCall.isra.0
Parsed function:SetScgHsrunDivcore_TrustedCall.isra.0
Parsed function:SetScgVlprDivslow_TrustedCall.isra.0
Parsed function:SetScgVlprDivbus_TrustedCall.isra.0
Parsed function:SetScgVlprDivcore_TrustedCall.isra.0
Parsed function:SetScgRunDivslow_TrustedCall.isra.0
Parsed function:SetScgRunDivbus_TrustedCall.isra.0
Parsed function:SetScgRunDivcore_TrustedCall.isra.0
Parsed function:SetSimTraceDivMul
Parsed function:SetSimTraceDivMul_TrustedCall
Parsed function:SetPccPcdDivFrac
Parsed function:SetPccPcdDivFrac_TrustedCall
Parsed function:SetSimClkoutDiv
Parsed function:SetScgHsrunDivslow
Parsed function:SetScgHsrunDivbus
Parsed function:SetScgHsrunDivcore
Parsed function:SetScgVlprDivslow
Parsed function:SetScgVlprDivbus
Parsed function:SetScgVlprDivcore
Parsed function:SetScgRunDivslow
Parsed function:SetScgRunDivbus
Parsed function:SetScgRunDivcore
Parsed function:SetScgAsyncDiv2
Parsed function:SetScgAsyncDiv2_TrustedCall
Parsed function:SetScgAsyncDiv1
Parsed function:SetScgAsyncDiv1_TrustedCall
Parsed function:Callback_DividerEmpty
Dump after hash based groups
Congruence classes: 12 (unique hash values: 12), with total: 30 items
Class size histogram [num of members]: number of classe number of classess
[1]: 7 classes
[3]: 3 classes
[4]: 1 classes
[10]: 1 classes


Dump after WPA based types groups
Congruence classes: 12 (unique hash values: 12), with total: 30 items
Class size histogram [num of members]: number of classe number of classess
[1]: 7 classes
[3]: 3 classes
[4]: 1 classes
[10]: 1 classes


Worklist has been filled with: 11
Address reference subdivision created: 0 new classes.
Dump after callgraph-based congruence reduction
Congruence classes: 18 (unique hash values: 12), with total: 30 items
Class size histogram [num of members]: number of classe number of classess
[1]: 12 classes
[3]: 6 classes


Init called for 18 items (60.00%).
Dump after full equality comparison of groups
Congruence classes: 30 (unique hash values: 12), with total: 30 items
Class size histogram [num of members]: number of classe number of classess
[1]: 30 classes


Worklist has been filled with: 29
Address reference subdivision created: 0 new classes.
Congruence classes: 30 (unique hash values: 12), with total: 30 items
Class size histogram [num of members]: number of classe number of classess
[1]: 30 classes



Item count: 30
Congruent classes before: 30, after: 30
Average class size before: 1.00, after: 1.00
Average non-singular class size: 0.00, count: 0
Equal symbols: 0
Fraction of visited symbols: 0.00%

SetSimClkoutDiv_TrustedCall.isra.0 (const uint32 ISRA.33)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;
  long unsigned int _6;
  long unsigned int _7;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.33_12(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SIM_Type *)1074036736B].CHIPCTL;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4294965503;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  _6 = _5 << 8;
  _7 = _6 & 1792;
  regValue_8 = regValue_4 | _7;
  # DEBUG regValue => regValue_8
  # DEBUG BEGIN_STMT
  MEM[(struct SIM_Type *)1074036736B].CHIPCTL ={v} regValue_8;

  <bb 4> [local count: 1073741824]:
  return;

}


SetScgHsrunDivslow_TrustedCall.isra.0 (const uint32 ISRA.30)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.30_10(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SCG_Type *)1074151424B].HCCR;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4294967280;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  regValue_6 = regValue_4 | _5;
  # DEBUG regValue => regValue_6
  # DEBUG BEGIN_STMT
  MEM[(struct SCG_Type *)1074151424B].HCCR ={v} regValue_6;

  <bb 4> [local count: 1073741824]:
  return;

}


SetScgHsrunDivbus_TrustedCall.isra.0 (const uint32 ISRA.27)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;
  long unsigned int _6;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.27_11(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SCG_Type *)1074151424B].HCCR;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4294967055;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  _6 = _5 << 4;
  regValue_7 = regValue_4 | _6;
  # DEBUG regValue => regValue_7
  # DEBUG BEGIN_STMT
  MEM[(struct SCG_Type *)1074151424B].HCCR ={v} regValue_7;

  <bb 4> [local count: 1073741824]:
  return;

}


SetScgHsrunDivcore_TrustedCall.isra.0 (const uint32 ISRA.24)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;
  long unsigned int _6;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.24_11(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SCG_Type *)1074151424B].HCCR;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4293984255;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  _6 = _5 << 16;
  regValue_7 = regValue_4 | _6;
  # DEBUG regValue => regValue_7
  # DEBUG BEGIN_STMT
  MEM[(struct SCG_Type *)1074151424B].HCCR ={v} regValue_7;

  <bb 4> [local count: 1073741824]:
  return;

}


SetScgVlprDivslow_TrustedCall.isra.0 (const uint32 ISRA.21)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.21_10(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SCG_Type *)1074151424B].VCCR;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4294967280;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  regValue_6 = regValue_4 | _5;
  # DEBUG regValue => regValue_6
  # DEBUG BEGIN_STMT
  MEM[(struct SCG_Type *)1074151424B].VCCR ={v} regValue_6;

  <bb 4> [local count: 1073741824]:
  return;

}


SetScgVlprDivbus_TrustedCall.isra.0 (const uint32 ISRA.18)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;
  long unsigned int _6;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.18_11(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SCG_Type *)1074151424B].VCCR;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4294967055;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  _6 = _5 << 4;
  regValue_7 = regValue_4 | _6;
  # DEBUG regValue => regValue_7
  # DEBUG BEGIN_STMT
  MEM[(struct SCG_Type *)1074151424B].VCCR ={v} regValue_7;

  <bb 4> [local count: 1073741824]:
  return;

}


SetScgVlprDivcore_TrustedCall.isra.0 (const uint32 ISRA.15)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;
  long unsigned int _6;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.15_11(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SCG_Type *)1074151424B].VCCR;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4293984255;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  _6 = _5 << 16;
  regValue_7 = regValue_4 | _6;
  # DEBUG regValue => regValue_7
  # DEBUG BEGIN_STMT
  MEM[(struct SCG_Type *)1074151424B].VCCR ={v} regValue_7;

  <bb 4> [local count: 1073741824]:
  return;

}


SetScgRunDivslow_TrustedCall.isra.0 (const uint32 ISRA.12)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.12_10(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SCG_Type *)1074151424B].RCCR;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4294967280;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  regValue_6 = regValue_4 | _5;
  # DEBUG regValue => regValue_6
  # DEBUG BEGIN_STMT
  MEM[(struct SCG_Type *)1074151424B].RCCR ={v} regValue_6;

  <bb 4> [local count: 1073741824]:
  return;

}


SetScgRunDivbus_TrustedCall.isra.0 (const uint32 ISRA.9)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;
  long unsigned int _6;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.9_11(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SCG_Type *)1074151424B].RCCR;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4294967055;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  _6 = _5 << 4;
  regValue_7 = regValue_4 | _6;
  # DEBUG regValue => regValue_7
  # DEBUG BEGIN_STMT
  MEM[(struct SCG_Type *)1074151424B].RCCR ={v} regValue_7;

  <bb 4> [local count: 1073741824]:
  return;

}


SetScgRunDivcore_TrustedCall.isra.0 (const uint32 ISRA.6)
{
  uint32 regValue;
  long unsigned int _2;
  long unsigned int _5;
  long unsigned int _6;

  <bb 5> [local count: 1073741824]:
  # DEBUG config s=> config

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = ISRA.6_11(D);
  if (_2 != 0)
    goto <bb 3>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 3> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  regValue_3 ={v} MEM[(struct SCG_Type *)1074151424B].RCCR;
  # DEBUG regValue => regValue_3
  # DEBUG BEGIN_STMT
  regValue_4 = regValue_3 & 4293984255;
  # DEBUG regValue => regValue_4
  # DEBUG BEGIN_STMT
  _5 = _2 + 4294967295;
  _6 = _5 << 16;
  regValue_7 = regValue_4 | _6;
  # DEBUG regValue => regValue_7
  # DEBUG BEGIN_STMT
  MEM[(struct SCG_Type *)1074151424B].RCCR ={v} regValue_7;

  <bb 4> [local count: 1073741824]:
  return;

}


SetSimTraceDivMul (const struct Clock_Ip_DividerConfigType * config)
{
  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  SetSimTraceDivMul_TrustedCall (config_2(D));
  return;

}


SetSimTraceDivMul_TrustedCall (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  unsigned char _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _1 ={v} MEM[(struct SIM_Type *)1074036736B].CLKDIV4;
  _2 = config_13(D)->value;
  _3 = _2 + 4294967295;
  _4 = _3 << 1;
  _5 = _4 & 14;
  _6 = config_13(D)->options[0];
  _7 = (long unsigned int) _6;
  _8 = _7 + 4294967295;
  _9 = _8 & 1;
  _10 = _5 | _9;
  _11 = _1 | _10;
  MEM[(struct SIM_Type *)1074036736B].CLKDIV4 ={v} _11;
  return;

}


SetPccPcdDivFrac (const struct Clock_Ip_DividerConfigType * config)
{
  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  SetPccPcdDivFrac_TrustedCall (config_2(D));
  return;

}


SetPccPcdDivFrac_TrustedCall (const struct Clock_Ip_DividerConfigType * config)
{
  uint32 regValue;
  <unnamed type> _1;
  unsigned char _2;
  int _3;
  long unsigned int _4;
  long unsigned int _5;
  long unsigned int _6;
  unsigned char _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = config_13(D)->name;
  _2 = clockFeatures[_1][5];
  _3 = (int) _2;
  regValue_14 ={v} MEM[(struct PCC_Type *)1074155520B].PCCn[_3];
  # DEBUG regValue => regValue_14
  # DEBUG BEGIN_STMT
  regValue_15 = regValue_14 & 4294967280;
  # DEBUG regValue => regValue_15
  # DEBUG BEGIN_STMT
  _4 = config_13(D)->value;
  _5 = _4 + 4294967295;
  _6 = _5 & 7;
  regValue_16 = _6 | regValue_15;
  # DEBUG regValue => regValue_16
  # DEBUG BEGIN_STMT
  _7 = config_13(D)->options[0];
  _8 = (long unsigned int) _7;
  _9 = _8 + 4294967295;
  _10 = _9 << 3;
  _11 = _10 & 8;
  regValue_17 = _11 | regValue_16;
  # DEBUG regValue => regValue_17
  # DEBUG BEGIN_STMT
  MEM[(struct PCC_Type *)1074155520B].PCCn[_3] ={v} regValue_17;
  return;

}


SetSimClkoutDiv (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#10 => config_2(D)
  SetSimClkoutDiv_TrustedCall.isra.0 (_4);
  return;

}


SetScgHsrunDivslow (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#9 => config_2(D)
  SetScgHsrunDivslow_TrustedCall.isra.0 (_4);
  return;

}


SetScgHsrunDivbus (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#8 => config_2(D)
  SetScgHsrunDivbus_TrustedCall.isra.0 (_4);
  return;

}


SetScgHsrunDivcore (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#7 => config_2(D)
  SetScgHsrunDivcore_TrustedCall.isra.0 (_4);
  return;

}


SetScgVlprDivslow (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#6 => config_2(D)
  SetScgVlprDivslow_TrustedCall.isra.0 (_4);
  return;

}


SetScgVlprDivbus (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#5 => config_2(D)
  SetScgVlprDivbus_TrustedCall.isra.0 (_4);
  return;

}


SetScgVlprDivcore (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#4 => config_2(D)
  SetScgVlprDivcore_TrustedCall.isra.0 (_4);
  return;

}


SetScgRunDivslow (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#3 => config_2(D)
  SetScgRunDivslow_TrustedCall.isra.0 (_4);
  return;

}


SetScgRunDivbus (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#2 => config_2(D)
  SetScgRunDivbus_TrustedCall.isra.0 (_4);
  return;

}


SetScgRunDivcore (const struct Clock_Ip_DividerConfigType * config)
{
  long unsigned int _4;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _4 = MEM[(long unsigned int *)config_2(D) + 4B];
  # DEBUG D#1 => config_2(D)
  SetScgRunDivcore_TrustedCall.isra.0 (_4);
  return;

}


SetScgAsyncDiv2 (const struct Clock_Ip_DividerConfigType * config)
{
  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  SetScgAsyncDiv2_TrustedCall (config_2(D));
  return;

}


SetScgAsyncDiv2_TrustedCall (const struct Clock_Ip_DividerConfigType * config)
{
  uint32 dividerValue;
  uint32 instance;
  uint32 regValue;
  <unnamed type> _1;
  unsigned char _2;
  long unsigned int _3;
  unsigned char _4;
  volatile struct scgPeriphAsyncDiv_Type * _5;
  long unsigned int _6;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = config_8(D)->name;
  _2 = clockFeatures[_1][0];
  instance_9 = (uint32) _2;
  # DEBUG instance => instance_9
  # DEBUG BEGIN_STMT
  _3 = config_8(D)->value;
  _4 = dividerValue_hardwareValue[_3];
  dividerValue_10 = (uint32) _4;
  # DEBUG dividerValue => dividerValue_10
  # DEBUG BEGIN_STMT
  _5 = scgPeriphAsyncDivs[instance_9];
  regValue_11 ={v} _5->ASYNC_DIV;
  # DEBUG regValue => regValue_11
  # DEBUG BEGIN_STMT
  regValue_12 = regValue_11 & 4294965503;
  # DEBUG regValue => regValue_12
  # DEBUG BEGIN_STMT
  _6 = dividerValue_10 << 8;
  regValue_13 = _6 | regValue_12;
  # DEBUG regValue => regValue_13
  # DEBUG BEGIN_STMT
  _5->ASYNC_DIV ={v} regValue_13;
  return;

}


SetScgAsyncDiv1 (const struct Clock_Ip_DividerConfigType * config)
{
  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  SetScgAsyncDiv1_TrustedCall (config_2(D));
  return;

}


SetScgAsyncDiv1_TrustedCall (const struct Clock_Ip_DividerConfigType * config)
{
  uint32 dividerValue;
  uint32 instance;
  uint32 regValue;
  <unnamed type> _1;
  unsigned char _2;
  long unsigned int _3;
  unsigned char _4;
  volatile struct scgPeriphAsyncDiv_Type * _5;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = config_7(D)->name;
  _2 = clockFeatures[_1][0];
  instance_8 = (uint32) _2;
  # DEBUG instance => instance_8
  # DEBUG BEGIN_STMT
  _3 = config_7(D)->value;
  _4 = dividerValue_hardwareValue[_3];
  dividerValue_9 = (uint32) _4;
  # DEBUG dividerValue => dividerValue_9
  # DEBUG BEGIN_STMT
  _5 = scgPeriphAsyncDivs[instance_8];
  regValue_10 ={v} _5->ASYNC_DIV;
  # DEBUG regValue => regValue_10
  # DEBUG BEGIN_STMT
  regValue_11 = regValue_10 & 4294967288;
  # DEBUG regValue => regValue_11
  # DEBUG BEGIN_STMT
  regValue_12 = dividerValue_9 | regValue_11;
  # DEBUG regValue => regValue_12
  # DEBUG BEGIN_STMT
  _5->ASYNC_DIV ={v} regValue_12;
  return;

}


Callback_DividerEmpty (const struct Clock_Ip_DividerConfigType * config)
{
  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  return;

}


