FlexCAN_Ip_ManualBusOffRecovery (uint8 Instance)
{
  Flexcan_Ip_StatusType RetVal;
  uint32 uS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * Base;
  Flexcan_Ip_StatusType D.8179;
  long unsigned int D.8176;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) Instance;
  Base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  timeStart = 0;
  # DEBUG BEGIN_STMT
  timeElapsed = 0;
  # DEBUG BEGIN_STMT
  uS2Ticks = OsIf_MicrosToTicks (10000, 0);
  # DEBUG BEGIN_STMT
  RetVal = 1;
  # DEBUG BEGIN_STMT
  _2 = Instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = Base->CTRL1;
  _4 = _3 & 64;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  RetVal = 0;
  # DEBUG BEGIN_STMT
  _5 = Base->ESR1;
  _6 = _5 & 32;
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_20 ();
  # DEBUG BEGIN_STMT
  _7 = Base->CTRL1;
  _8 = _7 & 4294967231;
  Base->CTRL1 = _8;
  # DEBUG BEGIN_STMT
  _9 = Base->CTRL1;
  _10 = _9 | 64;
  Base->CTRL1 = _10;
  # DEBUG BEGIN_STMT
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_20 ();
  # DEBUG BEGIN_STMT
  _11 = OsIf_GetCounter (0);
  timeStart = _11;
  # DEBUG BEGIN_STMT
  goto <bb 7>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  D.8176 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.8176 + timeElapsed;
  # DEBUG BEGIN_STMT
  if (timeElapsed >= uS2Ticks)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  RetVal = 3;
  # DEBUG BEGIN_STMT
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _12 = Base->ESR1;
  _13 = _12 & 32;
  if (_13 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  D.8179 = RetVal;
  timeStart = {CLOBBER};
  return D.8179;

}


FlexCAN_Ip_GetListenOnlyMode (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.8170;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  D.8170 = FlexCAN_IsListenOnlyModeEnabled (base);
  return D.8170;

}


FlexCAN_Ip_SetListenOnlyMode_Privileged (uint8 instance, const boolean enable)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8164;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_10 ();
  # DEBUG BEGIN_STMT
  FlexCAN_SetListenOnlyMode (pBase, enable);
  # DEBUG BEGIN_STMT
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_10 ();

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.8164 = result;
  return D.8164;

}


FlexCAN_Ip_SetRxMb15Mask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8150;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  freeze = 0;
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  pBase->RX15MASK = mask;

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.8150 = result;
  return D.8150;

}


FlexCAN_Ip_SetRxMb14Mask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8136;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  freeze = 0;
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  pBase->RX14MASK = mask;

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.8136 = result;
  return D.8136;

}


FlexCAN_Ip_AbortTransfer (uint8 u8Instance, uint8 mb_idx)
{
  Flexcan_Ip_StatusType result;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.8101;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = u8Instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = mb_idx + 224;
  _3 = _2 > 222;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_4];
  # DEBUG BEGIN_STMT
  _5 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_5];
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  if (mb_idx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _6 = (int) mb_idx;
  _7 = state->mbs[_6].state;
  if (_7 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  result = 5;
  goto <bb 9>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _8 = (long unsigned int) mb_idx;
  _9 = state->isIntActive;
  FLEXCAN_ClearMsgBuffIntCmd (pBase, u8Instance, _8, _9);
  # DEBUG BEGIN_STMT
  _10 = (int) mb_idx;
  _11 = state->mbs[_10].state;
  if (_11 == 2)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_AbortTxTransfer (u8Instance, mb_idx);

  <bb 7> :
  # DEBUG BEGIN_STMT
  _12 = (int) mb_idx;
  _13 = state->mbs[_12].state;
  if (_13 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  FlexCAN_AbortRxTransfer (u8Instance, mb_idx);

  <bb 9> :
  # DEBUG BEGIN_STMT
  D.8101 = result;
  return D.8101;

}


FlexCAN_Ip_SetErrorInt_Privileged (uint8 u8Instance, Flexcan_Ip_ErrorIntType type, boolean enable)
{
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8090;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = u8Instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  switch (type) <default: <L14> [INV], case 0: <L6> [INV], case 1: <L10> [INV], case 2: <L4> [INV], case 3: <L5> [INV], case 4: <L3> [INV]>

  <bb 6> :
<L3>:
  # DEBUG BEGIN_STMT
  FlexCAN_SetErrIntCmd (pBase, 32768, enable);
  # DEBUG BEGIN_STMT
  goto <bb 16>; [INV]

  <bb 7> :
<L4>:
  # DEBUG BEGIN_STMT
  FlexCAN_SetErrIntCmd (pBase, 16384, enable);
  # DEBUG BEGIN_STMT
  goto <bb 16>; [INV]

  <bb 8> :
<L5>:
  # DEBUG BEGIN_STMT
  FlexCAN_SetErrIntCmd (pBase, 16385, enable);
  # DEBUG BEGIN_STMT
  goto <bb 16>; [INV]

  <bb 9> :
<L6>:
  # DEBUG BEGIN_STMT
  _8 = FlexCAN_IsFreezeMode (pBase);
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  result = 1;
  goto <bb 16>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  FlexCAN_SetErrIntCmd (pBase, 1024, enable);
  goto <bb 16>; [INV]

  <bb 12> :
<L10>:
  # DEBUG BEGIN_STMT
  _10 = FlexCAN_IsFreezeMode (pBase);
  _11 = ~_10;
  if (_11 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  result = 1;
  goto <bb 16>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  FlexCAN_SetErrIntCmd (pBase, 2048, enable);
  goto <bb 16>; [INV]

  <bb 15> :
<L14>:
  # DEBUG BEGIN_STMT
  DevAssert (0);
  # DEBUG BEGIN_STMT

  <bb 16> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 19> :
  # DEBUG BEGIN_STMT
  D.8090 = result;
  return D.8090;

}


FlexCAN_Ip_DisableInterrupts_Privileged (uint8 u8Instance)
{
  struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.8074;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  result = 1;
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  _3 = u8Instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = FlexCAN_IsEnabled (pBase);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  FlexCAN_DisableInterrupts (pBase);
  # DEBUG BEGIN_STMT
  state->isIntActive = 0;
  # DEBUG BEGIN_STMT
  result = 0;

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.8074 = result;
  return D.8074;

}


FlexCAN_Ip_EnableInterrupts_Privileged (uint8 u8Instance)
{
  struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.8070;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  result = 1;
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  _3 = u8Instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = FlexCAN_IsEnabled (pBase);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  FlexCAN_EnableInterrupts (pBase, u8Instance);
  # DEBUG BEGIN_STMT
  state->isIntActive = 1;
  # DEBUG BEGIN_STMT
  result = 0;

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.8070 = result;
  return D.8070;

}


FlexCAN_Ip_ClearBuffStatusFlag (uint8 instance, uint8 msgBuffIdx)
{
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = (long unsigned int) msgBuffIdx;
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, _3);
  return;

}


FlexCAN_Ip_GetBuffStatusFlag (uint8 instance, uint8 msgBuffIdx)
{
  const struct FLEXCAN_Type * pBase;
  boolean returnResult;
  boolean D.8066;

  <bb 2> :
  # DEBUG BEGIN_STMT
  returnResult = 1;
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = (long unsigned int) msgBuffIdx;
  _4 = FlexCAN_GetBuffStatusFlag (pBase, _3);
  returnResult = _4 == 1;
  # DEBUG BEGIN_STMT
  D.8066 = returnResult;
  return D.8066;

}


FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged (uint8 instance, uint8 value)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8064;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_17 ();
  # DEBUG BEGIN_STMT
  FlexCAN_SetTxArbitrationStartDelay (pBase, value);
  # DEBUG BEGIN_STMT
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_17 ();

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.8064 = result;
  return D.8064;

}


FlexCAN_Ip_SetTDCOffset_Privileged (uint8 instance, boolean enable, uint8 offset)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8048;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  _8 = FlexCAN_IsFDAvailable (pBase);
  _9 = _8;
  DevAssert (_9);
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _10 = ~freeze;
  if (_10 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_16 ();
  # DEBUG BEGIN_STMT
  FlexCAN_SetTDCOffset (pBase, enable, offset);
  # DEBUG BEGIN_STMT
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_16 ();

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.8048 = result;
  return D.8048;

}


FlexCAN_Ip_GetBitrateFD (uint8 instance, struct Flexcan_Ip_TimeSegmentType * bitrate)
{
  boolean enhCbt;
  const struct FLEXCAN_Type * pBase;
  boolean D.8034;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = bitrate != 0B;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_3];
  # DEBUG BEGIN_STMT
  enhCbt = 0;
  # DEBUG BEGIN_STMT
  FlexCAN_GetFDTimeSegments (pBase, bitrate);
  # DEBUG BEGIN_STMT
  D.8034 = enhCbt;
  return D.8034;

}


FlexCAN_Ip_SetBitrateCbt_Privileged (uint8 instance, const struct Flexcan_Ip_TimeSegmentType * bitrate, boolean bitRateSwitch)
{
  boolean freeze;
  boolean fd_enable;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8030;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = bitrate != 0B;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _3 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_3];
  # DEBUG BEGIN_STMT
  _4 = FlexCAN_IsEnabled (pBase);
  _5 = (int) _4;
  _6 = _5 != 0;
  _7 = ~_6;
  _8 = (int) _7;
  disabled = (boolean) _8;
  # DEBUG BEGIN_STMT
  fd_enable = FlexCAN_IsFDEnabled (pBase);
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _9 = ~fd_enable;
  if (_9 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _10 = ~freeze;
  if (_10 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (result == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 8> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_15 ();
  # DEBUG BEGIN_STMT
  FlexCAN_SetFDEnabled (pBase, fd_enable, bitRateSwitch);
  # DEBUG BEGIN_STMT
  FlexCAN_SetFDTimeSegments (pBase, bitrate);
  # DEBUG BEGIN_STMT
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_15 ();

  <bb 10> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 13> :
  # DEBUG BEGIN_STMT
  D.8030 = result;
  return D.8030;

}


FlexCAN_Ip_GetTDCValue (uint8 u8Instance)
{
  const struct FLEXCAN_Type * pBase;
  uint8 value;
  uint8 D.8016;

  <bb 2> :
  # DEBUG BEGIN_STMT
  value = 0;
  # DEBUG BEGIN_STMT
  _1 = u8Instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = pBase->FDCTRL;
  _4 = (unsigned char) _3;
  value = _4 & 63;
  # DEBUG BEGIN_STMT
  D.8016 = value;
  return D.8016;

}


FlexCAN_Ip_GetTDCFail (uint8 u8Instance)
{
  const struct FLEXCAN_Type * pBase;
  boolean value;
  boolean D.8014;

  <bb 2> :
  # DEBUG BEGIN_STMT
  value = 0;
  # DEBUG BEGIN_STMT
  _1 = u8Instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = pBase->FDCTRL;
  _4 = _3 & 16384;
  value = _4 == 16384;
  # DEBUG BEGIN_STMT
  D.8014 = value;
  return D.8014;

}


FlexCAN_Ip_ClearTDCFail (uint8 u8Instance)
{
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = u8Instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_09 ();
  # DEBUG BEGIN_STMT
  _3 = pBase->FDCTRL;
  _4 = _3 | 16384;
  pBase->FDCTRL = _4;
  # DEBUG BEGIN_STMT
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_09 ();
  return;

}


FlexCAN_Ip_GetBitrate (uint8 instance, struct Flexcan_Ip_TimeSegmentType * bitrate)
{
  boolean enhCbt;
  const struct FLEXCAN_Type * pBase;
  boolean D.8012;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = bitrate != 0B;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_3];
  # DEBUG BEGIN_STMT
  enhCbt = 0;
  # DEBUG BEGIN_STMT
  _4 = FlexCAN_IsExCbtEnabled (pBase);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  FlexCAN_GetExtendedTimeSegments (pBase, bitrate);
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  FlexCAN_GetTimeSegments (pBase, bitrate);

  <bb 5> :
  # DEBUG BEGIN_STMT
  D.8012 = enhCbt;
  return D.8012;

}


FlexCAN_Ip_SetBitrate_Privileged (uint8 instance, const struct Flexcan_Ip_TimeSegmentType * bitrate, boolean enhExt)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.8005;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = bitrate != 0B;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _3 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_3];
  # DEBUG BEGIN_STMT
  _4 = FlexCAN_IsEnabled (pBase);
  _5 = (int) _4;
  _6 = _5 != 0;
  _7 = ~_6;
  _8 = (int) _7;
  disabled = (boolean) _8;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _9 = ~freeze;
  if (_9 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_14 ();
  # DEBUG BEGIN_STMT
  _10 = FlexCAN_IsExCbtEnabled (pBase);
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  FlexCAN_SetExtendedTimeSegments (pBase, bitrate);
  goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  FlexCAN_SetTimeSegments (pBase, bitrate);

  <bb 11> :
  # DEBUG BEGIN_STMT
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_14 ();

  <bb 12> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 15> :
  # DEBUG BEGIN_STMT
  D.8005 = result;
  return D.8005;

}


FlexCAN_Ip_SetRxMaskType_Privileged (uint8 instance, Flexcan_Ip_RxMaskType type)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7985;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_08 ();
  # DEBUG BEGIN_STMT
  FlexCAN_SetRxMaskType (pBase, type);
  # DEBUG BEGIN_STMT
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_08 ();

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.7985 = result;
  return D.7985;

}


FlexCAN_Ip_SetStopMode_Privileged (uint8 instance)
{
  Flexcan_Ip_StatusType status;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.7971;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  status = FlexCAN_EnterFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  if (status == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.7971 = status;
  return D.7971;

}


FlexCAN_Ip_SetStartMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.7967;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_07 ();
  # DEBUG BEGIN_STMT
  _3 = pBase->MCR;
  _4 = _3 & 2147483647;
  pBase->MCR = _4;
  # DEBUG BEGIN_STMT
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_07 ();
  # DEBUG BEGIN_STMT
  D.7967 = FlexCAN_ExitFreezeMode (pBase);
  return D.7967;

}


FlexCAN_Ip_GetStartMode_Privileged (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.7965;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = base->MCR;
  _3 = _2 & 17825792;
  D.7965 = _3 == 0;
  return D.7965;

}


FlexCAN_Ip_GetStopMode_Privileged (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  boolean D.7963;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = base->MCR;
  _3 = _2 & 1048576;
  D.7963 = _3 == 1048576;
  return D.7963;

}


FlexCAN_Ip_MainFunctionWrite (uint8 instance, uint8 mb_idx)
{
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = (long unsigned int) mb_idx;
  _5 = FlexCAN_GetBuffStatusFlag (base, _4);
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _6 = (long unsigned int) mb_idx;
  _7 = (int) mb_idx;
  _8 = FlexCAN_GetMsgBuffTimestamp (base, _6);
  state->mbs[_7].time_stamp = _8;
  # DEBUG BEGIN_STMT
  FlexCAN_UnlockRxMsgBuff (base);
  # DEBUG BEGIN_STMT
  _9 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _9);
  # DEBUG BEGIN_STMT
  _10 = (int) mb_idx;
  state->mbs[_10].state = 0;

  <bb 4> :
  return;

}


FlexCAN_Ip_MainFunctionBusOff_Privileged (uint8 instance)
{
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType eRetVal;
  Flexcan_Ip_StatusType D.7959;

  <bb 2> :
  # DEBUG BEGIN_STMT
  eRetVal = 1;
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  u32ErrStatus = 0;
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  u32ErrStatus = base->ESR1;
  # DEBUG BEGIN_STMT
  _4 = u32ErrStatus & 4;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _5 = state->error_callback;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _6 = state->error_callback;
  _6 (instance, 7, u32ErrStatus, state);

  <bb 5> :
  # DEBUG BEGIN_STMT
  base->ESR1 = 4;
  # DEBUG BEGIN_STMT
  eRetVal = 0;

  <bb 6> :
  # DEBUG BEGIN_STMT
  D.7959 = eRetVal;
  return D.7959;

}


FlexCAN_Ip_MainFunctionRead (uint8 instance, uint8 mb_idx)
{
  const struct Flexcan_Ip_StateType * state;
  const struct FLEXCAN_Type * base;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = mb_idx <= 31;
  DevAssert (_4);
  # DEBUG BEGIN_STMT
  _5 = state->bIsLegacyFifoEn;
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  if (mb_idx <= 7)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (mb_idx == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _6 = FlexCAN_GetBuffStatusFlag (base, 5);
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  FlexCAN_IRQHandlerRxFIFO (instance, 5);
  goto <bb 10>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _7 = (long unsigned int) mb_idx;
  _8 = FlexCAN_GetBuffStatusFlag (base, _7);
  if (_8 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _9 = (int) mb_idx;
  _10 = state->mbs[_9].state;
  if (_10 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _11 = (long unsigned int) mb_idx;
  FlexCAN_IRQHandlerRxMB (instance, _11);

  <bb 10> :
  return;

}


FlexCAN_Ip_Deinit_Privileged (uint8 instance)
{
  Flexcan_Ip_StatusType result;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.7939;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  result = 1;
  # DEBUG BEGIN_STMT
  _2 = instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  result = FlexCAN_EnterFreezeMode (base);
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  FlexCAN_SetRegDefaultVal (base);
  # DEBUG BEGIN_STMT
  FlexCAN_Disable (base);
  # DEBUG BEGIN_STMT
  _3 = (int) instance;
  Flexcan_Ip_apxState[_3] = 0B;

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.7939 = result;
  return D.7939;

}


FlexCAN_Ip_SetRxFifoGlobalMask_Privileged (uint8 instance, uint32 mask)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7935;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  FlexCAN_SetRxFifoGlobalMask (pBase, mask);

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.7935 = result;
  return D.7935;

}


FlexCAN_Ip_SetRxIndividualMask_Privileged (uint8 instance, uint8 mb_idx, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7921;

  <bb 2> :
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  freeze = 0;
  # DEBUG BEGIN_STMT
  _2 = instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = (long unsigned int) mb_idx;
  _4 = pBase->MCR;
  _5 = _4 & 127;
  if (_3 > _5)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (mb_idx > 31)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  result = 4;
  goto <bb 15>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _6 = FlexCAN_IsEnabled (pBase);
  _7 = (int) _6;
  _8 = _7 != 0;
  _9 = ~_8;
  _10 = (int) _9;
  disabled = (boolean) _10;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 7> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _11 = ~freeze;
  if (_11 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  if (result == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 10> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _12 = (long unsigned int) mb_idx;
  FlexCAN_SetRxIndividualMask (pBase, _12, mask);

  <bb 12> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 15> :
  # DEBUG BEGIN_STMT
  D.7921 = result;
  return D.7921;

}


FlexCAN_Ip_ExitFreezeMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.7903;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  D.7903 = FlexCAN_ExitFreezeMode (base);
  return D.7903;

}


FlexCAN_Ip_EnterFreezeMode_Privileged (uint8 instance)
{
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.7901;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  D.7901 = FlexCAN_EnterFreezeMode (base);
  return D.7901;

}


FlexCAN_Ip_SetRxMbGlobalMask_Privileged (uint8 instance, uint32 mask)
{
  boolean disabled;
  boolean freeze;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7899;

  <bb 2> :
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  freeze = 0;
  # DEBUG BEGIN_STMT
  _2 = instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  FlexCAN_SetRxMsgBuffGlobalMask (pBase, mask);

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.7899 = result;
  return D.7899;

}


FlexCAN_Ip_SendBlocking (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data, uint32 timeout_ms)
{
  volatile uint32 * flexcan_mb;
  uint32 flexcan_mb_config;
  uint32 uS2Ticks;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7884;
  long unsigned int D.7877;
  long unsigned int D.7870;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  timeStart = 0;
  # DEBUG BEGIN_STMT
  timeElapsed = 0;
  # DEBUG BEGIN_STMT
  _3 = timeout_ms * 1000;
  mS2Ticks = OsIf_MicrosToTicks (_3, 0);
  # DEBUG BEGIN_STMT
  uS2Ticks = 0;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = 0;
  # DEBUG BEGIN_STMT
  flexcan_mb = 0B;
  # DEBUG BEGIN_STMT
  _4 = instance <= 2;
  DevAssert (_4);
  # DEBUG BEGIN_STMT
  _5 = tx_info != 0B;
  DevAssert (_5);
  # DEBUG BEGIN_STMT
  result = FlexCAN_StartSendData (instance, mb_idx, tx_info, msg_id, mb_data);
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _6 = OsIf_GetCounter (0);
  timeStart = _6;
  # DEBUG BEGIN_STMT
  goto <bb 6>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.7870 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.7870 + timeElapsed;
  # DEBUG BEGIN_STMT
  if (timeElapsed >= mS2Ticks)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  result = 3;
  # DEBUG BEGIN_STMT
  goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _7 = (long unsigned int) mb_idx;
  _8 = FlexCAN_GetBuffStatusFlag (base, _7);
  if (_8 != 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 3)
    goto <bb 8>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 8> :
  _9 = (int) mb_idx;
  _10 = state->mbs[_9].state;
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _11 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _11);
  # DEBUG BEGIN_STMT
  _12 = (long unsigned int) mb_idx;
  flexcan_mb = FlexCAN_GetMsgBuffRegion (base, _12);
  # DEBUG BEGIN_STMT
  flexcan_mb_config = *flexcan_mb;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config | 150994944;
  # DEBUG BEGIN_STMT
  *flexcan_mb = flexcan_mb_config;
  # DEBUG BEGIN_STMT
  uS2Ticks = OsIf_MicrosToTicks (10000, 0);
  # DEBUG BEGIN_STMT
  _13 = OsIf_GetCounter (0);
  timeStart = _13;
  # DEBUG BEGIN_STMT
  timeElapsed = 0;
  # DEBUG BEGIN_STMT
  goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  D.7877 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.7877 + timeElapsed;
  # DEBUG BEGIN_STMT
  if (timeElapsed >= uS2Ticks)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = 3;
  # DEBUG BEGIN_STMT
  goto <bb 13>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  _14 = (long unsigned int) mb_idx;
  _15 = FlexCAN_GetBuffStatusFlag (base, _14);
  if (_15 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  flexcan_mb_config = *flexcan_mb;
  # DEBUG BEGIN_STMT
  _16 = flexcan_mb_config >> 24;
  _17 = _16 & 15;
  if (_17 == 8)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  result = 0;

  <bb 15> :
  # DEBUG BEGIN_STMT
  _18 = flexcan_mb_config >> 24;
  _19 = _18 & 15;
  if (_19 == 9)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  result = 3;

  <bb 17> :
  # DEBUG BEGIN_STMT
  _20 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _20);
  # DEBUG BEGIN_STMT
  _21 = (int) mb_idx;
  state->mbs[_21].state = 0;

  <bb 18> :
  # DEBUG BEGIN_STMT
  D.7884 = result;
  timeStart = {CLOBBER};
  return D.7884;

}


FlexCAN_BusOff_IRQHandler (uint8 instance)
{
  boolean isSpuriousInt;
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  u32ErrStatus = 0;
  # DEBUG BEGIN_STMT
  isSpuriousInt = 1;
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  if (state != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  u32ErrStatus = base->ESR1;
  # DEBUG BEGIN_STMT
  _4 = u32ErrStatus & 131072;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _5 = base->CTRL1;
  _6 = _5 & 2048;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  base->ESR1 = 131072;
  # DEBUG BEGIN_STMT
  _7 = state->error_callback;
  if (_7 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _8 = state->error_callback;
  _8 (instance, 9, u32ErrStatus, state);
  # DEBUG BEGIN_STMT
  u32ErrStatus = base->ESR1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  isSpuriousInt = 0;

  <bb 8> :
  # DEBUG BEGIN_STMT
  _9 = u32ErrStatus & 65536;
  if (_9 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  _10 = base->CTRL1;
  _11 = _10 & 1024;
  if (_11 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  base->ESR1 = 65536;
  # DEBUG BEGIN_STMT
  _12 = state->error_callback;
  if (_12 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _13 = state->error_callback;
  _13 (instance, 8, u32ErrStatus, state);
  # DEBUG BEGIN_STMT
  u32ErrStatus = base->ESR1;

  <bb 12> :
  # DEBUG BEGIN_STMT
  isSpuriousInt = 0;

  <bb 13> :
  # DEBUG BEGIN_STMT
  _14 = u32ErrStatus & 4;
  if (_14 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 14> :
  _15 = base->CTRL1;
  _16 = _15 & 32768;
  if (_16 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  base->ESR1 = 4;
  # DEBUG BEGIN_STMT
  _17 = state->error_callback;
  if (_17 != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  _18 = state->error_callback;
  _18 (instance, 7, u32ErrStatus, state);

  <bb 17> :
  # DEBUG BEGIN_STMT
  isSpuriousInt = 0;

  <bb 18> :
  # DEBUG BEGIN_STMT
  if (isSpuriousInt != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  base->ESR1 = 720900;

  <bb 20> :
  return;

}


FlexCAN_Error_IRQHandler (uint8 instance)
{
  boolean isSpuriousInt;
  uint32 u32ErrStatus;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  u32ErrStatus = 0;
  # DEBUG BEGIN_STMT
  isSpuriousInt = 1;
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  if (state != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  u32ErrStatus = pBase->ESR1;
  # DEBUG BEGIN_STMT
  _4 = u32ErrStatus & 2;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _5 = pBase->CTRL1;
  _6 = _5 & 16384;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  pBase->ESR1 = 2;
  # DEBUG BEGIN_STMT
  _7 = state->error_callback;
  if (_7 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _8 = state->error_callback;
  _8 (instance, 5, u32ErrStatus, state);
  # DEBUG BEGIN_STMT
  u32ErrStatus = pBase->ESR1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  isSpuriousInt = 0;

  <bb 8> :
  # DEBUG BEGIN_STMT
  _9 = u32ErrStatus & 1048576;
  if (_9 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 9> :
  _10 = pBase->CTRL2;
  _11 = (signed int) _10;
  if (_11 < 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  pBase->ESR1 = 1048576;
  # DEBUG BEGIN_STMT
  _12 = state->error_callback;
  if (_12 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _13 = state->error_callback;
  _13 (instance, 6, u32ErrStatus, state);

  <bb 12> :
  # DEBUG BEGIN_STMT
  isSpuriousInt = 0;

  <bb 13> :
  # DEBUG BEGIN_STMT
  if (isSpuriousInt != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  pBase->ESR1 = 3145730;

  <bb 15> :
  return;

}


FlexCAN_Ip_GetControllerRxErrorCounter (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint8 D.7828;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = base->ECR;
  _4 = _3 >> 8;
  D.7828 = (uint8) _4;
  return D.7828;

}


FlexCAN_Ip_GetControllerTxErrorCounter (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint8 D.7826;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = base->ECR;
  D.7826 = (uint8) _3;
  return D.7826;

}


FlexCAN_Ip_GetErrorStatus (uint8 instance)
{
  const struct FLEXCAN_Type * base;
  uint32 D.7824;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  D.7824 = base->ESR1;
  return D.7824;

}


FlexCAN_Ip_ClearErrorStatus (uint8 instance, uint32 error)
{
  struct FLEXCAN_Type * base;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  base->ESR1 = error;
  return;

}


FlexCAN_IRQHandler (uint8 instance, uint32 startMbIdx, uint32 endMbIdx)
{
  uint32 mb_idx;
  boolean bIsSpuriousInt;
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  uint32 flag_reg;
  uint32 u32MbHandle;

  <bb 2> :
  # DEBUG BEGIN_STMT
  u32MbHandle = 0;
  # DEBUG BEGIN_STMT
  flag_reg = 0;
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  bIsSpuriousInt = 1;
  # DEBUG BEGIN_STMT
  mb_idx = endMbIdx;
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = endMbIdx <= 31;
  DevAssert (_4);
  # DEBUG BEGIN_STMT
  if (state != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _5 = FlexCAN_GetMsgBuffIntStatusFlag (base, mb_idx);
  flag_reg = (uint32) _5;
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  mb_idx = mb_idx + 4294967295;
  # DEBUG BEGIN_STMT
  _6 = FlexCAN_GetMsgBuffIntStatusFlag (base, mb_idx);
  flag_reg = (uint32) _6;

  <bb 5> :
  # DEBUG BEGIN_STMT
  if (flag_reg == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  if (mb_idx > startMbIdx)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (flag_reg != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  bIsSpuriousInt = 0;
  # DEBUG BEGIN_STMT
  u32MbHandle = mb_idx;
  # DEBUG BEGIN_STMT
  _7 = state->bIsLegacyFifoEn;
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  if (mb_idx <= 7)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  FlexCAN_IRQHandlerRxFIFO (instance, mb_idx);
  # DEBUG BEGIN_STMT
  u32MbHandle = 0;
  goto <bb 13>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _8 = state->mbs[u32MbHandle].state;
  if (_8 == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  FlexCAN_IRQHandlerRxMB (instance, mb_idx);

  <bb 13> :
  # DEBUG BEGIN_STMT
  _9 = state->mbs[u32MbHandle].state;
  if (_9 == 2)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  FlexCAN_IRQHandlerTxMB (instance, mb_idx);

  <bb 15> :
  # DEBUG BEGIN_STMT
  _10 = FlexCAN_GetMsgBuffIntStatusFlag (base, mb_idx);
  if (_10 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  _11 = state->mbs[u32MbHandle].state;
  if (_11 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);

  <bb 18> :
  # DEBUG BEGIN_STMT
  if (bIsSpuriousInt != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  FlexCAN_ProcessSpuriousInterruptMB (instance, startMbIdx, endMbIdx);
  goto <bb 23>; [INV]

  <bb 20> :
  # DEBUG BEGIN_STMT
  mb_idx = startMbIdx;
  goto <bb 22>; [INV]

  <bb 21> :
  # DEBUG BEGIN_STMT
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  # DEBUG BEGIN_STMT
  mb_idx = mb_idx + 1;

  <bb 22> :
  # DEBUG BEGIN_STMT
  if (mb_idx <= endMbIdx)
    goto <bb 21>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  return;

}


FlexCAN_CompleteRxMessageFifoData (uint8 instance)
{
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = state->transferType;
  if (_4 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _5 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 5, 0, _5);
  # DEBUG BEGIN_STMT
  _6 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 6, 0, _6);
  # DEBUG BEGIN_STMT
  _7 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 7, 0, _7);

  <bb 4> :
  # DEBUG BEGIN_STMT
  state->mbs[0].pMBmessage = 0B;
  # DEBUG BEGIN_STMT
  state->mbs[0].state = 0;
  return;

}


FlexCAN_Ip_GetTransferStatus (uint8 instance, uint8 mb_idx)
{
  Flexcan_Ip_StatusType status;
  const struct Flexcan_Ip_StateType * state;
  Flexcan_Ip_StatusType D.7766;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  state = Flexcan_Ip_apxState[_1];
  # DEBUG BEGIN_STMT
  status = 1;
  # DEBUG BEGIN_STMT
  _2 = instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = mb_idx + 224;
  _4 = _3 > 222;
  DevAssert (_4);
  # DEBUG BEGIN_STMT
  if (mb_idx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _5 = (int) mb_idx;
  _6 = state->mbs[_5].state;
  if (_6 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  status = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  status = 2;

  <bb 6> :
  # DEBUG BEGIN_STMT
  D.7766 = status;
  return D.7766;

}


FlexCAN_Ip_ConfigRemoteResponseMb (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  volatile uint32 * pMbAddr;
  const struct Flexcan_Ip_StateType * const state;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7758;

  <bb 2> :
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  pMbAddr = 0B;
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = tx_info != 0B;
  DevAssert (_4);
  # DEBUG BEGIN_STMT
  _5 = pBase->CTRL2;
  _6 = _5 & 131072;
  _7 = _6 == 0;
  DevAssert (_7);
  # DEBUG BEGIN_STMT
  _8 = tx_info->data_length;
  _9 = (unsigned char) _8;
  _10 = (long unsigned int) mb_idx;
  _11 = FlexCAN_GetMbPayloadSize (pBase, _10);
  _12 = _9 <= _11;
  DevAssert (_12);
  # DEBUG BEGIN_STMT
  _13 = state->bIsLegacyFifoEn;
  _14 = state->u32MaxMbNum;
  _15 = FlexCAN_IsMbOutOfRange (pBase, mb_idx, _13, _14);
  if (_15 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = 4;

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _16 = tx_info->data_length;
  cs.dataLen = _16;
  # DEBUG BEGIN_STMT
  _17 = tx_info->msg_id_type;
  cs.msgIdType = _17;
  # DEBUG BEGIN_STMT
  cs.code = 10;
  # DEBUG BEGIN_STMT
  cs.fd_enable = 0;
  # DEBUG BEGIN_STMT
  cs.enable_brs = 0;
  # DEBUG BEGIN_STMT
  cs.fd_padding = 0;
  # DEBUG BEGIN_STMT
  _18 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, _18);
  # DEBUG BEGIN_STMT
  _19 = (long unsigned int) mb_idx;
  pMbAddr = FlexCAN_GetMsgBuffRegion (pBase, _19);
  # DEBUG BEGIN_STMT
  _20 = tx_info->is_remote;
  FlexCAN_SetTxMsgBuff (pMbAddr, &cs, msg_id, mb_data, _20);
  # DEBUG BEGIN_STMT
  _21 = tx_info->is_polling;
  _22 = ~_21;
  if (_22 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _23 = (long unsigned int) mb_idx;
  _24 = state->isIntActive;
  result = FlexCAN_SetMsgBuffIntCmd (pBase, instance, _23, 1, _24);

  <bb 7> :
  # DEBUG BEGIN_STMT
  D.7758 = result;
  cs = {CLOBBER};
  return D.7758;

}


FlexCAN_Ip_ConfigRxFifo_Privileged (uint8 instance, Flexcan_Ip_RxFifoIdElementFormatType id_format, const struct Flexcan_Ip_IdTableType * id_filter_table)
{
  boolean freeze;
  boolean disabled;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType status;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7748;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  status = 0;
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_IsEnabled (pBase);
  _4 = (int) _3;
  _5 = _4 != 0;
  _6 = ~_5;
  _7 = (int) _6;
  disabled = (boolean) _7;
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_Enable (pBase);

  <bb 4> :
  # DEBUG BEGIN_STMT
  freeze = FlexCAN_IsFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  _8 = ~freeze;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  result = 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  FlexCAN_SetRxFifoFilter (pBase, id_format, id_filter_table);

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (disabled != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  status = FlexCAN_Disable (pBase);
  # DEBUG BEGIN_STMT
  if (status != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = status;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.7748 = result;
  return D.7748;

}


FlexCAN_Ip_RxFifoBlocking (uint8 instance, struct Flexcan_Ip_MsgBuffType * data, uint32 timeout)
{
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7705;

  <bb 2> :
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = FlexCAN_StartRxMessageFifoData (instance, data);
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_ProccessLegacyRxFIFO (instance, timeout);

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.7705 = result;
  return D.7705;

}


FlexCAN_Ip_RxFifo (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7689;

  <bb 2> :
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  result = FlexCAN_StartRxMessageFifoData (instance, data);
  # DEBUG BEGIN_STMT
  D.7689 = result;
  return D.7689;

}


FlexCAN_Ip_ReceiveBlocking (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling, uint32 u32TimeoutMs)
{
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_StateType * state;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7658;
  long unsigned int D.7644;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  timeStart = 0;
  # DEBUG BEGIN_STMT
  timeElapsed = 0;
  # DEBUG BEGIN_STMT
  _1 = u32TimeoutMs * 1000;
  mS2Ticks = OsIf_MicrosToTicks (_1, 0);
  # DEBUG BEGIN_STMT
  _2 = instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = (int) instance;
  state = Flexcan_Ip_apxState[_3];
  # DEBUG BEGIN_STMT
  _4 = (int) instance;
  base = Flexcan_Ip_apxBase[_4];
  # DEBUG BEGIN_STMT
  result = FlexCAN_StartRxMessageBufferData (instance, mb_idx, data, isPolling);
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _5 = ~isPolling;
  if (_5 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _6 = (long unsigned int) mb_idx;
  _7 = state->isIntActive;
  result = FlexCAN_SetMsgBuffIntCmd (base, instance, _6, 1, _7);

  <bb 5> :
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _8 = OsIf_GetCounter (0);
  timeStart = _8;
  # DEBUG BEGIN_STMT
  goto <bb 12>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (isPolling != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _9 = (long unsigned int) mb_idx;
  _10 = FlexCAN_GetBuffStatusFlag (base, _9);
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _11 = (long unsigned int) mb_idx;
  FlexCAN_IRQHandlerRxMB (instance, _11);

  <bb 10> :
  # DEBUG BEGIN_STMT
  D.7644 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.7644 + timeElapsed;
  # DEBUG BEGIN_STMT
  if (timeElapsed >= mS2Ticks)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  result = 3;
  # DEBUG BEGIN_STMT
  goto <bb 13>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  _12 = (int) mb_idx;
  _13 = state->mbs[_12].state;
  if (_13 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  if (result == 3)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _14 = ~isPolling;
  if (_14 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  _15 = (long unsigned int) mb_idx;
  _16 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, _15, 0, _16);

  <bb 16> :
  # DEBUG BEGIN_STMT
  if (result != 4)
    goto <bb 17>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 17> :
  if (result != 2)
    goto <bb 18>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  _17 = (int) mb_idx;
  _18 = state->mbs[_17].state;
  if (_18 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  result = 0;
  goto <bb 21>; [INV]

  <bb 20> :
  # DEBUG BEGIN_STMT
  _19 = (int) mb_idx;
  state->mbs[_19].state = 0;
  # DEBUG BEGIN_STMT
  result = 3;

  <bb 21> :
  # DEBUG BEGIN_STMT
  D.7658 = result;
  timeStart = {CLOBBER};
  return D.7658;

}


FlexCAN_Ip_Receive (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7624;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  result = FlexCAN_StartRxMessageBufferData (instance, mb_idx, data, isPolling);
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _4 = ~isPolling;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _5 = (long unsigned int) mb_idx;
  _6 = state->isIntActive;
  result = FlexCAN_SetMsgBuffIntCmd (base, instance, _5, 1, _6);

  <bb 5> :
  # DEBUG BEGIN_STMT
  D.7624 = result;
  return D.7624;

}


FlexCAN_Ip_ConfigRxMb (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * rx_info, uint32 msg_id)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7617;

  <bb 2> :
  # DEBUG BEGIN_STMT
  eResult = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = rx_info != 0B;
  DevAssert (_4);
  # DEBUG BEGIN_STMT
  _5 = state->bIsLegacyFifoEn;
  _6 = state->u32MaxMbNum;
  _7 = FlexCAN_IsMbOutOfRange (base, mb_idx, _5, _6);
  if (_7 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  eResult = 4;
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _8 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _8);
  # DEBUG BEGIN_STMT
  _9 = rx_info->data_length;
  cs.dataLen = _9;
  # DEBUG BEGIN_STMT
  _10 = rx_info->msg_id_type;
  cs.msgIdType = _10;
  # DEBUG BEGIN_STMT
  _11 = rx_info->fd_enable;
  cs.fd_enable = _11;
  # DEBUG BEGIN_STMT
  cs.code = 15;
  # DEBUG BEGIN_STMT
  _12 = (long unsigned int) mb_idx;
  FlexCAN_SetRxMsgBuff (base, _12, &cs, msg_id);
  # DEBUG BEGIN_STMT
  cs.code = 0;
  # DEBUG BEGIN_STMT
  _13 = (long unsigned int) mb_idx;
  FlexCAN_SetRxMsgBuff (base, _13, &cs, msg_id);
  # DEBUG BEGIN_STMT
  cs.code = 4;
  # DEBUG BEGIN_STMT
  _14 = (long unsigned int) mb_idx;
  FlexCAN_SetRxMsgBuff (base, _14, &cs, msg_id);

  <bb 5> :
  # DEBUG BEGIN_STMT
  D.7617 = eResult;
  cs = {CLOBBER};
  return D.7617;

}


FlexCAN_Ip_Send (uint8 instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  const struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7596;

  <bb 2> :
  # DEBUG BEGIN_STMT
  result = 1;
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = tx_info != 0B;
  DevAssert (_4);
  # DEBUG BEGIN_STMT
  _5 = FlexCAN_IsListenOnlyModeEnabled (base);
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = FlexCAN_StartSendData (instance, mb_idx, tx_info, msg_id, mb_data);
  # DEBUG BEGIN_STMT
  if (result == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _7 = tx_info->is_polling;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _9 = (long unsigned int) mb_idx;
  _10 = state->isIntActive;
  result = FlexCAN_SetMsgBuffIntCmd (base, instance, _9, 1, _10);

  <bb 6> :
  # DEBUG BEGIN_STMT
  D.7596 = result;
  return D.7596;

}


FlexCAN_Ip_Init_Privileged (uint8 Flexcan_Ip_u8Instance, struct Flexcan_Ip_StateType * Flexcan_Ip_pState, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  uint32 i;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7537;

  <bb 2> :
  # DEBUG BEGIN_STMT
  eResult = 0;
  # DEBUG BEGIN_STMT
  _1 = (int) Flexcan_Ip_u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = Flexcan_Ip_u8Instance <= 2;
  DevAssert (_2);
  # DEBUG BEGIN_STMT
  _3 = Flexcan_Ip_pData != 0B;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = Flexcan_Ip_pData->fd_enable;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _5 = FlexCAN_IsFDAvailable (pBase);
  _6 = Flexcan_Ip_pData->fd_enable;
  _7 = _5 == _6;
  DevAssert (_7);

  <bb 4> :
  # DEBUG BEGIN_STMT
  eResult = FlexCAN_InitController (pBase, Flexcan_Ip_pData);
  # DEBUG BEGIN_STMT
  if (eResult == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _8 = Flexcan_Ip_pData->fd_enable;
  FlexCAN_EnableExtCbt (pBase, _8);
  # DEBUG BEGIN_STMT
  _9 = Flexcan_Ip_pData->fd_enable;
  if (_9 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _10 = &Flexcan_Ip_pData->bitrate;
  FlexCAN_SetExtendedTimeSegments (pBase, _10);
  # DEBUG BEGIN_STMT
  _11 = &Flexcan_Ip_pData->bitrate_cbt;
  FlexCAN_SetFDTimeSegments (pBase, _11);
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _12 = &Flexcan_Ip_pData->bitrate;
  FlexCAN_SetTimeSegments (pBase, _12);

  <bb 8> :
  # DEBUG BEGIN_STMT
  _13 = Flexcan_Ip_pData->flexcanMode;
  FlexCAN_SetOperationMode (pBase, _13);
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  Flexcan_Ip_pState->mbs[i].isPolling = 1;
  # DEBUG BEGIN_STMT
  Flexcan_Ip_pState->mbs[i].pMBmessage = 0B;
  # DEBUG BEGIN_STMT
  Flexcan_Ip_pState->mbs[i].state = 0;
  # DEBUG BEGIN_STMT
  Flexcan_Ip_pState->mbs[i].time_stamp = 0;
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 10> :
  # DEBUG BEGIN_STMT
  if (i <= 31)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _14 = Flexcan_Ip_pData->transfer_type;
  Flexcan_Ip_pState->transferType = _14;
  # DEBUG BEGIN_STMT
  _15 = Flexcan_Ip_pData->Callback;
  Flexcan_Ip_pState->callback = _15;
  # DEBUG BEGIN_STMT
  Flexcan_Ip_pState->callbackParam = 0B;
  # DEBUG BEGIN_STMT
  _16 = Flexcan_Ip_pData->ErrorCallback;
  Flexcan_Ip_pState->error_callback = _16;
  # DEBUG BEGIN_STMT
  Flexcan_Ip_pState->errorCallbackParam = 0B;
  # DEBUG BEGIN_STMT
  _17 = Flexcan_Ip_pData->is_rx_fifo_needed;
  Flexcan_Ip_pState->bIsLegacyFifoEn = _17;
  # DEBUG BEGIN_STMT
  _18 = Flexcan_Ip_pData->max_num_mb;
  Flexcan_Ip_pState->u32MaxMbNum = _18;
  # DEBUG BEGIN_STMT
  Flexcan_Ip_pState->isIntActive = 1;
  # DEBUG BEGIN_STMT
  _19 = (int) Flexcan_Ip_u8Instance;
  Flexcan_Ip_apxState[_19] = Flexcan_Ip_pState;

  <bb 12> :
  # DEBUG BEGIN_STMT
  D.7537 = eResult;
  return D.7537;

}


FlexCAN_AbortRxTransfer (uint8 u8Instance, uint8 mb_idx)
{
  volatile uint32 * flexcan_mb;
  uint32 flexcan_mb_config;
  uint32 val2;
  uint32 val1;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  val1 = 0;
  # DEBUG BEGIN_STMT
  val2 = 0;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = 0;
  # DEBUG BEGIN_STMT
  flexcan_mb = 0B;
  # DEBUG BEGIN_STMT
  _3 = (int) mb_idx;
  state->mbs[_3].state = 0;
  # DEBUG BEGIN_STMT
  _4 = state->bIsLegacyFifoEn;
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _5 = pBase->CTRL2;
  _6 = _5 >> 24;
  val1 = _6 & 15;
  # DEBUG BEGIN_STMT
  val2 = RxFifoOcuppiedLastMsgBuff (val1);
  # DEBUG BEGIN_STMT
  _7 = (long unsigned int) mb_idx;
  if (val2 < _7)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _8 = (long unsigned int) mb_idx;
  flexcan_mb = FlexCAN_GetMsgBuffRegion (pBase, _8);
  # DEBUG BEGIN_STMT
  flexcan_mb_config = *flexcan_mb;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config;
  # DEBUG BEGIN_STMT
  *flexcan_mb = flexcan_mb_config;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config | 67108864;
  # DEBUG BEGIN_STMT
  *flexcan_mb = flexcan_mb_config;

  <bb 5> :
  # DEBUG BEGIN_STMT
  if (mb_idx == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _9 = state->isIntActive;
  FLEXCAN_ClearMsgBuffIntCmd (pBase, u8Instance, 5, _9);
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _10 = (long unsigned int) mb_idx;
  flexcan_mb = FlexCAN_GetMsgBuffRegion (pBase, _10);
  # DEBUG BEGIN_STMT
  flexcan_mb_config = *flexcan_mb;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config;
  # DEBUG BEGIN_STMT
  *flexcan_mb = flexcan_mb_config;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config | 67108864;
  # DEBUG BEGIN_STMT
  *flexcan_mb = flexcan_mb_config;

  <bb 8> :
  # DEBUG BEGIN_STMT
  _11 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, _11);
  return;

}


FlexCAN_AbortTxTransfer (uint8 u8Instance, uint8 mb_idx)
{
  volatile uint32 * flexcan_mb;
  uint32 uS2Ticks;
  uint32 flexcan_mb_config;
  uint32 timeElapsed;
  uint32 timeStart;
  Flexcan_Ip_StatusType result;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * pBase;
  Flexcan_Ip_StatusType D.8112;
  long unsigned int D.8103;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  timeStart = 0;
  # DEBUG BEGIN_STMT
  timeElapsed = 0;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = 0;
  # DEBUG BEGIN_STMT
  uS2Ticks = 0;
  # DEBUG BEGIN_STMT
  flexcan_mb = 0B;
  # DEBUG BEGIN_STMT
  _3 = (long unsigned int) mb_idx;
  flexcan_mb = FlexCAN_GetMsgBuffRegion (pBase, _3);
  # DEBUG BEGIN_STMT
  flexcan_mb_config = *flexcan_mb;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config & 4043309055;
  # DEBUG BEGIN_STMT
  flexcan_mb_config = flexcan_mb_config | 150994944;
  # DEBUG BEGIN_STMT
  *flexcan_mb = flexcan_mb_config;
  # DEBUG BEGIN_STMT
  uS2Ticks = OsIf_MicrosToTicks (10000, 0);
  # DEBUG BEGIN_STMT
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  D.8103 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.8103 + timeElapsed;
  # DEBUG BEGIN_STMT
  if (timeElapsed >= uS2Ticks)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  result = 3;
  # DEBUG BEGIN_STMT
  goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _5 = (long unsigned int) mb_idx;
  _6 = FlexCAN_GetBuffStatusFlag (pBase, _5);
  if (_6 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  if (result != 3)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  flexcan_mb_config = *flexcan_mb;
  # DEBUG BEGIN_STMT
  _7 = flexcan_mb_config >> 24;
  _8 = _7 & 15;
  if (_8 == 8)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  result = 5;

  <bb 9> :
  # DEBUG BEGIN_STMT
  _9 = flexcan_mb_config >> 24;
  _10 = _9 & 15;
  if (_10 == 9)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  result = 0;

  <bb 11> :
  # DEBUG BEGIN_STMT
  _11 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, _11);
  # DEBUG BEGIN_STMT
  _12 = (int) mb_idx;
  state->mbs[_12].state = 0;
  # DEBUG BEGIN_STMT
  D.8112 = result;
  timeStart = {CLOBBER};
  return D.8112;

}


FlexCAN_ProcessSpuriousInterruptMB (uint8 instance, uint32 startMbIdx, uint32 endMbIdx)
{
  uint32 u32MbHandle;
  uint32 mb_idx;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  mb_idx = 0;
  # DEBUG BEGIN_STMT
  u32MbHandle = 0;
  # DEBUG BEGIN_STMT
  mb_idx = startMbIdx;
  goto <bb 12>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _3 = FlexCAN_GetBuffStatusFlag (base, mb_idx);
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 4> :
  _4 = FlexCAN_GetBuffStatusImask (base, mb_idx);
  if (_4 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  u32MbHandle = mb_idx;
  # DEBUG BEGIN_STMT
  _5 = state->bIsLegacyFifoEn;
  if (_5 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (mb_idx <= 7)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  u32MbHandle = 0;

  <bb 8> :
  # DEBUG BEGIN_STMT
  _6 = state->mbs[u32MbHandle].isPolling;
  _7 = ~_6;
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  # DEBUG BEGIN_STMT
  _8 = state->mbs[u32MbHandle].state;
  if (_8 == 2)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  state->mbs[u32MbHandle].state = 0;
  # DEBUG BEGIN_STMT
  state->mbs[u32MbHandle].isPolling = 1;

  <bb 11> :
  # DEBUG BEGIN_STMT
  mb_idx = mb_idx + 1;

  <bb 12> :
  # DEBUG BEGIN_STMT
  if (mb_idx <= endMbIdx)
    goto <bb 3>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  return;

}


FlexCAN_IRQHandlerRxFIFO (uint8 instance, uint32 mb_idx)
{
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _3 = state->mbs[0].pMBmessage;
  if (_3 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  state->mbs[0].pMBmessage = &data;

  <bb 4> :
  # DEBUG BEGIN_STMT
  switch (mb_idx) <default: <L17> [INV], case 5: <L2> [INV], case 6: <L9> [INV], case 7: <L12> [INV]>

  <bb 5> :
<L2>:
  # DEBUG BEGIN_STMT
  _4 = state->mbs[0].state;
  if (_4 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _5 = state->mbs[0].pMBmessage;
  FlexCAN_ReadRxFifo (base, _5);
  # DEBUG BEGIN_STMT
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  # DEBUG BEGIN_STMT
  state->mbs[0].state = 0;
  # DEBUG BEGIN_STMT
  _6 = state->callback;
  if (_6 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _7 = state->callback;
  _7 (instance, 1, 0, state);

  <bb 8> :
  # DEBUG BEGIN_STMT
  _8 = state->mbs[0].state;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  state->mbs[0].isPolling = 1;
  # DEBUG BEGIN_STMT
  FlexCAN_CompleteRxMessageFifoData (instance);
  goto <bb 14>; [INV]

  <bb 10> :
<L9>:
  # DEBUG BEGIN_STMT
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  # DEBUG BEGIN_STMT
  _9 = state->callback;
  if (_9 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _10 = state->callback;
  _10 (instance, 2, 0, state);
  goto <bb 14>; [INV]

  <bb 12> :
<L12>:
  # DEBUG BEGIN_STMT
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  # DEBUG BEGIN_STMT
  _11 = state->callback;
  if (_11 != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  _12 = state->callback;
  _12 (instance, 3, 0, state);

  <bb 14> :
<L17>:
  data = {CLOBBER};
  return;

}


FlexCAN_IRQHandlerTxMB (uint8 u8Instance, uint32 u32MbIdx)
{
  boolean bCurrentIntStat;
  struct Flexcan_Ip_MsgBuffType mb;
  struct Flexcan_Ip_StateType * pState;
  struct FLEXCAN_Type * pBase;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  pState = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  bCurrentIntStat = 0;
  # DEBUG BEGIN_STMT
  _3 = pState->mbs[u32MbIdx].isRemote;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  FlexCAN_LockRxMsgBuff (pBase, u32MbIdx);
  # DEBUG BEGIN_STMT
  FlexCAN_GetMsgBuff (pBase, u32MbIdx, &mb);
  # DEBUG BEGIN_STMT
  FlexCAN_UnlockRxMsgBuff (pBase);
  # DEBUG BEGIN_STMT
  _4 = mb.time_stamp;
  pState->mbs[u32MbIdx].time_stamp = _4;
  # DEBUG BEGIN_STMT
  _5 = mb.cs;
  _6 = _5 >> 24;
  _7 = _6 & 15;
  if (_7 == 4)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, u32MbIdx);
  goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _8 = FlexCAN_GetMsgBuffTimestamp (pBase, u32MbIdx);
  pState->mbs[u32MbIdx].time_stamp = _8;
  # DEBUG BEGIN_STMT
  FlexCAN_UnlockRxMsgBuff (pBase);
  # DEBUG BEGIN_STMT
  FlexCAN_ClearMsgBuffIntStatusFlag (pBase, u32MbIdx);

  <bb 6> :
  # DEBUG BEGIN_STMT
  pState->mbs[u32MbIdx].state = 0;
  # DEBUG BEGIN_STMT
  bCurrentIntStat = pState->mbs[u32MbIdx].isPolling;
  # DEBUG BEGIN_STMT
  _9 = pState->callback;
  if (_9 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _10 = pState->callback;
  _10 (u8Instance, 4, u32MbIdx, pState);

  <bb 8> :
  # DEBUG BEGIN_STMT
  _11 = pState->mbs[u32MbIdx].state;
  if (_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _12 = pState->mbs[u32MbIdx].isPolling;
  _13 = ~_12;
  if (_13 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  pState->mbs[u32MbIdx].isPolling = 1;
  # DEBUG BEGIN_STMT
  _14 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, u32MbIdx, 0, _14);
  goto <bb 14>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _15 = ~bCurrentIntStat;
  if (_15 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 12> :
  _16 = pState->mbs[u32MbIdx].isPolling;
  if (_16 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  _17 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, u32MbIdx, 0, _17);

  <bb 14> :
  # DEBUG BEGIN_STMT
  mb = {CLOBBER};
  return;

}


FlexCAN_IRQHandlerRxMB (uint8 instance, uint32 mb_idx)
{
  volatile uint32 * flexcan_mb;
  boolean bIsCriticalSectionNeeded;
  boolean bCurrentIntStat;
  struct Flexcan_Ip_MsgBuffType data;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  bCurrentIntStat = 0;
  # DEBUG BEGIN_STMT
  _3 = state->mbs[mb_idx].pMBmessage;
  if (_3 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  state->mbs[mb_idx].pMBmessage = &data;

  <bb 4> :
  # DEBUG BEGIN_STMT
  bIsCriticalSectionNeeded = 0;
  # DEBUG BEGIN_STMT
  _4 = state->mbs[mb_idx].isPolling;
  if (_4 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _5 = state->bIsLegacyFifoEn;
  if (_5 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  bIsCriticalSectionNeeded = 1;
  # DEBUG BEGIN_STMT
  __asm__ __volatile__(" cpsid i");

  <bb 7> :
  # DEBUG BEGIN_STMT
  FlexCAN_LockRxMsgBuff (base, mb_idx);
  # DEBUG BEGIN_STMT
  _6 = state->mbs[mb_idx].pMBmessage;
  FlexCAN_GetMsgBuff (base, mb_idx, _6);
  # DEBUG BEGIN_STMT
  FlexCAN_ClearMsgBuffIntStatusFlag (base, mb_idx);
  # DEBUG BEGIN_STMT
  _7 = state->bIsLegacyFifoEn;
  if (_7 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _8 = state->mbs[mb_idx].pMBmessage;
  _9 = _8->cs;
  _10 = _9 >> 24;
  _11 = _10 & 15;
  if (_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  flexcan_mb = FlexCAN_GetMsgBuffRegion (base, mb_idx);
  # DEBUG BEGIN_STMT
  _12 = *flexcan_mb;
  _13 = _12 & 4043309055;
  *flexcan_mb = _13;
  # DEBUG BEGIN_STMT
  _14 = *flexcan_mb;
  _15 = _14 | 67108864;
  *flexcan_mb = _15;
  goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  FlexCAN_UnlockRxMsgBuff (base);

  <bb 11> :
  # DEBUG BEGIN_STMT
  if (bIsCriticalSectionNeeded != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  __asm__ __volatile__(" cpsie i");

  <bb 13> :
  # DEBUG BEGIN_STMT
  state->mbs[mb_idx].state = 0;
  # DEBUG BEGIN_STMT
  bCurrentIntStat = state->mbs[mb_idx].isPolling;
  # DEBUG BEGIN_STMT
  _16 = state->callback;
  if (_16 != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  _17 = state->callback;
  _17 (instance, 0, mb_idx, state);

  <bb 15> :
  # DEBUG BEGIN_STMT
  _18 = state->mbs[mb_idx].state;
  if (_18 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _19 = state->mbs[mb_idx].isPolling;
  _20 = ~_19;
  if (_20 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  state->mbs[mb_idx].isPolling = 1;
  # DEBUG BEGIN_STMT
  _21 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, mb_idx, 0, _21);
  goto <bb 21>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  _22 = ~bCurrentIntStat;
  if (_22 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  _23 = state->mbs[mb_idx].isPolling;
  if (_23 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  # DEBUG BEGIN_STMT
  _24 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, mb_idx, 0, _24);

  <bb 21> :
  # DEBUG BEGIN_STMT
  data = {CLOBBER};
  return;

}


FlexCAN_StartRxMessageFifoData (uint8 instance, struct Flexcan_Ip_MsgBuffType * data)
{
  Flexcan_Ip_StatusType eResult;
  struct Flexcan_Ip_StateType * state;
  struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType D.7701;

  <bb 2> :
  # DEBUG BEGIN_STMT
  base = 0B;
  # DEBUG BEGIN_STMT
  state = 0B;
  # DEBUG BEGIN_STMT
  eResult = 0;
  # DEBUG BEGIN_STMT
  _1 = instance <= 2;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  base = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  _3 = (int) instance;
  state = Flexcan_Ip_apxState[_3];
  # DEBUG BEGIN_STMT
  _4 = state->bIsLegacyFifoEn;
  _5 = ~_4;
  if (_5 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  eResult = 1;
  goto <bb 10>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _6 = state->mbs[0].state;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  eResult = 2;
  goto <bb 10>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  state->mbs[0].state = 1;
  # DEBUG BEGIN_STMT
  _7 = state->transferType;
  if (_7 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  state->mbs[0].isPolling = 1;

  <bb 8> :
  # DEBUG BEGIN_STMT
  state->mbs[0].pMBmessage = data;
  # DEBUG BEGIN_STMT
  _8 = state->transferType;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  state->mbs[0].isPolling = 0;
  # DEBUG BEGIN_STMT
  _9 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 6, 1, _9);
  # DEBUG BEGIN_STMT
  _10 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 7, 1, _10);
  # DEBUG BEGIN_STMT
  _11 = state->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (base, instance, 5, 1, _11);

  <bb 10> :
  # DEBUG BEGIN_STMT
  D.7701 = eResult;
  return D.7701;

}


FlexCAN_StartSendData (uint8 Flexcan_Ip_u8Instance, uint8 mb_idx, const struct Flexcan_Ip_DataInfoType * tx_info, uint32 msg_id, const uint8 * mb_data)
{
  volatile uint32 * pMbAddr;
  struct FLEXCAN_Type * base;
  struct Flexcan_Ip_StateType * state;
  struct Flexcan_Ip_MsbuffCodeStatusType cs;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7609;

  <bb 2> :
  # DEBUG BEGIN_STMT
  eResult = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = (int) Flexcan_Ip_u8Instance;
  state = Flexcan_Ip_apxState[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) Flexcan_Ip_u8Instance;
  base = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  pMbAddr = 0B;
  # DEBUG BEGIN_STMT
  _3 = Flexcan_Ip_u8Instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = tx_info != 0B;
  DevAssert (_4);
  # DEBUG BEGIN_STMT
  _5 = tx_info->data_length;
  _6 = (unsigned char) _5;
  _7 = (long unsigned int) mb_idx;
  _8 = FlexCAN_GetMbPayloadSize (base, _7);
  _9 = _6 <= _8;
  DevAssert (_9);
  # DEBUG BEGIN_STMT
  _10 = state->bIsLegacyFifoEn;
  _11 = state->u32MaxMbNum;
  _12 = FlexCAN_IsMbOutOfRange (base, mb_idx, _10, _11);
  if (_12 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  eResult = 4;
  goto <bb 10>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _13 = (int) mb_idx;
  _14 = state->mbs[_13].state;
  if (_14 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  eResult = 2;
  goto <bb 10>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _15 = (long unsigned int) mb_idx;
  FlexCAN_ClearMsgBuffIntStatusFlag (base, _15);
  # DEBUG BEGIN_STMT
  _16 = (int) mb_idx;
  state->mbs[_16].state = 2;
  # DEBUG BEGIN_STMT
  _17 = (int) mb_idx;
  state->mbs[_17].time_stamp = 0;
  # DEBUG BEGIN_STMT
  _18 = (int) mb_idx;
  _19 = tx_info->is_polling;
  state->mbs[_18].isPolling = _19;
  # DEBUG BEGIN_STMT
  _20 = (int) mb_idx;
  _21 = tx_info->is_remote;
  state->mbs[_20].isRemote = _21;
  # DEBUG BEGIN_STMT
  _22 = tx_info->data_length;
  cs.dataLen = _22;
  # DEBUG BEGIN_STMT
  _23 = tx_info->msg_id_type;
  cs.msgIdType = _23;
  # DEBUG BEGIN_STMT
  _24 = tx_info->fd_enable;
  cs.fd_enable = _24;
  # DEBUG BEGIN_STMT
  _25 = tx_info->fd_padding;
  cs.fd_padding = _25;
  # DEBUG BEGIN_STMT
  _26 = tx_info->enable_brs;
  cs.enable_brs = _26;
  # DEBUG BEGIN_STMT
  _27 = tx_info->is_remote;
  if (_27 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  cs.code = 28;
  goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  cs.code = 12;

  <bb 9> :
  # DEBUG BEGIN_STMT
  _28 = (long unsigned int) mb_idx;
  pMbAddr = FlexCAN_GetMsgBuffRegion (base, _28);
  # DEBUG BEGIN_STMT
  FlexCAN_SetTxMsgBuff (pMbAddr, &cs, msg_id, mb_data, 0);

  <bb 10> :
  # DEBUG BEGIN_STMT
  D.7609 = eResult;
  cs = {CLOBBER};
  return D.7609;

}


FlexCAN_StartRxMessageBufferData (uint8 instance, uint8 mb_idx, struct Flexcan_Ip_MsgBuffType * data, boolean isPolling)
{
  struct Flexcan_Ip_StateType * state;
  const struct FLEXCAN_Type * base;
  Flexcan_Ip_StatusType result;
  Flexcan_Ip_StatusType D.7632;

  <bb 2> :
  # DEBUG BEGIN_STMT
  result = 0;
  # DEBUG BEGIN_STMT
  _1 = (int) instance;
  base = Flexcan_Ip_apxBase[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) instance;
  state = Flexcan_Ip_apxState[_2];
  # DEBUG BEGIN_STMT
  _3 = instance <= 2;
  DevAssert (_3);
  # DEBUG BEGIN_STMT
  _4 = state->bIsLegacyFifoEn;
  _5 = state->u32MaxMbNum;
  _6 = FlexCAN_IsMbOutOfRange (base, mb_idx, _4, _5);
  if (_6 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  result = 4;
  goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _7 = (int) mb_idx;
  _8 = state->mbs[_7].state;
  if (_8 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  result = 2;
  goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _9 = (int) mb_idx;
  state->mbs[_9].state = 1;
  # DEBUG BEGIN_STMT
  _10 = (int) mb_idx;
  state->mbs[_10].pMBmessage = data;
  # DEBUG BEGIN_STMT
  _11 = (int) mb_idx;
  state->mbs[_11].isPolling = isPolling;

  <bb 7> :
  # DEBUG BEGIN_STMT
  D.7632 = result;
  return D.7632;

}


FlexCAN_ProccessLegacyRxFIFO (uint8 u8Instance, uint32 u32TimeoutMs)
{
  uint32 u32intType;
  uint32 mS2Ticks;
  uint32 timeElapsed;
  uint32 timeStart;
  struct FLEXCAN_Type * pBase;
  struct Flexcan_Ip_StateType * pState;
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7718;
  long unsigned int D.7711;

  <bb 2> :
  # DEBUG BEGIN_STMT
  eResult = 0;
  # DEBUG BEGIN_STMT
  _1 = (int) u8Instance;
  pState = Flexcan_Ip_apxState[_1];
  # DEBUG BEGIN_STMT
  _2 = (int) u8Instance;
  pBase = Flexcan_Ip_apxBase[_2];
  # DEBUG BEGIN_STMT
  timeStart = 0;
  # DEBUG BEGIN_STMT
  timeElapsed = 0;
  # DEBUG BEGIN_STMT
  _3 = u32TimeoutMs * 1000;
  mS2Ticks = OsIf_MicrosToTicks (_3, 0);
  # DEBUG BEGIN_STMT
  u32intType = 0;
  # DEBUG BEGIN_STMT
  _4 = OsIf_GetCounter (0);
  timeStart = _4;
  # DEBUG BEGIN_STMT
  goto <bb 11>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _5 = pState->transferType;
  if (_5 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  u32intType = 7;
  goto <bb 8>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _6 = FlexCAN_GetBuffStatusFlag (pBase, u32intType);
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  FlexCAN_IRQHandlerRxFIFO (u8Instance, u32intType);

  <bb 7> :
  # DEBUG BEGIN_STMT
  u32intType = u32intType + 4294967295;

  <bb 8> :
  # DEBUG BEGIN_STMT
  if (u32intType > 4)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  D.7711 = OsIf_GetElapsed (&timeStart, 0);
  timeElapsed = D.7711 + timeElapsed;
  # DEBUG BEGIN_STMT
  if (timeElapsed >= mS2Ticks)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  eResult = 3;
  # DEBUG BEGIN_STMT
  goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _7 = pState->mbs[0].state;
  if (_7 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  if (eResult == 3)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _8 = pState->transferType;
  if (_8 != 1)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  _9 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, 5, 0, _9);
  # DEBUG BEGIN_STMT
  _10 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, 6, 0, _10);
  # DEBUG BEGIN_STMT
  _11 = pState->isIntActive;
  FlexCAN_SetMsgBuffIntCmd (pBase, u8Instance, 7, 0, _11);

  <bb 15> :
  # DEBUG BEGIN_STMT
  _12 = pState->mbs[0].state;
  switch (_12) <default: <L18> [INV], case 0: <L17> [INV], case 1: <L16> [INV]>

  <bb 16> :
<L16>:
  # DEBUG BEGIN_STMT
  pState->mbs[0].state = 0;
  # DEBUG BEGIN_STMT
  goto <bb 19>; [INV]

  <bb 17> :
<L17>:
  # DEBUG BEGIN_STMT
  eResult = 0;
  # DEBUG BEGIN_STMT
  goto <bb 19>; [INV]

  <bb 18> :
<L18>:
  # DEBUG BEGIN_STMT
  eResult = 1;
  # DEBUG BEGIN_STMT

  <bb 19> :
  # DEBUG BEGIN_STMT
  D.7718 = eResult;
  timeStart = {CLOBBER};
  return D.7718;

}


FlexCAN_InitController (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7553;

  <bb 2> :
  # DEBUG BEGIN_STMT
  eResult = 0;
  # DEBUG BEGIN_STMT
  _1 = FlexCAN_IsEnabled (pBase);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  eResult = FlexCAN_EnterFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  if (eResult == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  eResult = FlexCAN_Disable (pBase);

  <bb 5> :
  # DEBUG BEGIN_STMT
  if (eResult == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _2 = Flexcan_Ip_pData->is_pe_clock;
  FlexCAN_SetClkSrc (pBase, _2);
  # DEBUG BEGIN_STMT
  _3 = pBase->MCR;
  _4 = _3 & 2147483647;
  pBase->MCR = _4;
  # DEBUG BEGIN_STMT
  eResult = FlexCAN_Init (pBase);
  # DEBUG BEGIN_STMT
  if (eResult != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  FlexCAN_EnterFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  FlexCAN_Disable (pBase);
  goto <bb 11>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _5 = FlexCAN_IsFDAvailable (pBase);
  if (_5 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _6 = Flexcan_Ip_pData->fd_enable;
  _7 = Flexcan_Ip_pData->bitRateSwitch;
  FlexCAN_SetFDEnabled (pBase, _6, _7);

  <bb 10> :
  # DEBUG BEGIN_STMT
  _8 = Flexcan_Ip_pData->ctrlOptions;
  FlexCAN_ConfigCtrlOptions (pBase, _8);
  # DEBUG BEGIN_STMT
  eResult = FlexCAN_InitCtroll (pBase, Flexcan_Ip_pData);

  <bb 11> :
  # DEBUG BEGIN_STMT
  D.7553 = eResult;
  return D.7553;

}


FlexCAN_InitCtroll (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7576;

  <bb 2> :
  # DEBUG BEGIN_STMT
  eResult = 0;
  # DEBUG BEGIN_STMT
  _1 = Flexcan_Ip_pData->flexcanMode;
  if (_1 != 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  FlexCAN_SetSelfReception (pBase, 0);

  <bb 4> :
  # DEBUG BEGIN_STMT
  eResult = FlexCAN_InitRxFifo (pBase, Flexcan_Ip_pData);
  # DEBUG BEGIN_STMT
  if (eResult != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  FlexCAN_EnterFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  FlexCAN_Disable (pBase);
  goto <bb 8>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _2 = &Flexcan_Ip_pData->payload;
  FlexCAN_SetPayloadSize (pBase, _2);
  # DEBUG BEGIN_STMT
  _3 = Flexcan_Ip_pData->max_num_mb;
  eResult = FlexCAN_SetMaxMsgBuffNum (pBase, _3);
  # DEBUG BEGIN_STMT
  if (eResult != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  FlexCAN_EnterFreezeMode (pBase);
  # DEBUG BEGIN_STMT
  FlexCAN_Disable (pBase);

  <bb 8> :
  # DEBUG BEGIN_STMT
  D.7576 = eResult;
  return D.7576;

}


FlexCAN_InitRxFifo (struct FLEXCAN_Type * pBase, const struct Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
  Flexcan_Ip_StatusType eResult;
  Flexcan_Ip_StatusType D.7584;

  <bb 2> :
  # DEBUG BEGIN_STMT
  eResult = 0;
  # DEBUG BEGIN_STMT
  _1 = Flexcan_Ip_pData->is_rx_fifo_needed;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _2 = Flexcan_Ip_pData->num_id_filters;
  eResult = FlexCAN_EnableRxFifo (pBase, _2);

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.7584 = eResult;
  return D.7584;

}


FlexCAN_SetRegDefaultVal (struct FLEXCAN_Type * base)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = FlexCAN_IsFDAvailable (base);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  base->FDCBT = 0;
  # DEBUG BEGIN_STMT
  base->FDCTRL = 2147500288;

  <bb 4> :
  # DEBUG BEGIN_STMT
  base->IFLAG1 = 4294967295;
  # DEBUG BEGIN_STMT
  base->IMASK1 = 0;
  # DEBUG BEGIN_STMT
  base->CBT = 0;
  # DEBUG BEGIN_STMT
  base->CTRL2 = 1048576;
  # DEBUG BEGIN_STMT
  base->ESR1 = 241670;
  # DEBUG BEGIN_STMT
  base->ECR = 0;
  # DEBUG BEGIN_STMT
  base->TIMER = 0;
  # DEBUG BEGIN_STMT
  base->CTRL1 = 0;
  # DEBUG BEGIN_STMT
  base->MCR = 3633315855;
  return;

}


FlexCAN_SetRxMaskType (struct FLEXCAN_Type * base, Flexcan_Ip_RxMaskType type)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  if (type == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = base->MCR;
  _2 = _1 & 4294901759;
  base->MCR = _2;
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _3 = base->MCR;
  _4 = _3 | 65536;
  base->MCR = _4;

  <bb 5> :
  return;

}


FlexCAN_SetTxArbitrationStartDelay (struct FLEXCAN_Type * base, uint8 tasd)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->CTRL2;
  _2 = _1 & 4278714367;
  _3 = (long unsigned int) tasd;
  _4 = _3 << 19;
  _5 = _4 & 16252928;
  _6 = _2 | _5;
  base->CTRL2 = _6;
  return;

}


FlexCAN_IsFreezeMode (const struct FLEXCAN_Type * base)
{
  boolean D.7750;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->MCR;
  _2 = _1 & 16777216;
  D.7750 = _2 != 0;
  return D.7750;

}


FlexCAN_SetRxIndividualMask (struct FLEXCAN_Type * base, uint32 msgBuffIdx, uint32 mask)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  base->RXIMR[msgBuffIdx] = mask;
  return;

}


FlexCAN_SetRxMsgBuffGlobalMask (struct FLEXCAN_Type * base, uint32 Mask)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  base->RXMGMASK = Mask;
  return;

}


FlexCAN_GetMsgBuffIntStatusFlag (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 mask;
  uint8 flag;
  uint8 D.7806;

  <bb 2> :
  # DEBUG BEGIN_STMT
  flag = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (msgBuffIdx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  mask = base->IMASK1;
  # DEBUG BEGIN_STMT
  _1 = base->IFLAG1;
  _2 = mask & _1;
  _3 = msgBuffIdx & 31;
  _4 = _2 >> _3;
  _5 = (unsigned char) _4;
  flag = _5 & 1;

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.7806 = flag;
  return D.7806;

}


FlexCAN_SetClkSrc (struct FLEXCAN_Type * base, boolean enable)
{
  long unsigned int iftmp.1;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->CTRL1;
  _2 = _1 & 4294959103;
  if (enable != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.1 = 8192;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.1 = 0;

  <bb 5> :
  _3 = iftmp.1 | _2;
  base->CTRL1 = _3;
  return;

}


RxFifoOcuppiedLastMsgBuff (uint32 x)
{
  uint32 D.8122;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = x + 1;
  _2 = _1 * 8;
  _3 = _2 / 4;
  D.8122 = _3 + 5;
  return D.8122;

}


FlexCAN_IsListenOnlyModeEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.7598;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->CTRL1;
  _2 = _1 & 8;
  D.7598 = _2 != 0;
  return D.7598;

}


FlexCAN_IsFDEnabled (const struct FLEXCAN_Type * base)
{
  boolean D.8032;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->MCR;
  _2 = _1 & 2048;
  D.8032 = _2 != 0;
  return D.8032;

}


FlexCAN_SetSelfReception (struct FLEXCAN_Type * base, boolean enable)
{
  long unsigned int iftmp.4;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->MCR;
  _2 = _1 & 4294836223;
  if (enable != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.4 = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.4 = 131072;

  <bb 5> :
  _3 = iftmp.4 | _2;
  base->MCR = _3;
  return;

}


FlexCAN_EnableExtCbt (struct FLEXCAN_Type * base, boolean enableCBT)
{
  long unsigned int iftmp.5;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->CBT;
  _2 = _1 & 2147483647;
  if (enableCBT != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.5 = 2147483648;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.5 = 0;

  <bb 5> :
  _3 = iftmp.5 | _2;
  base->CBT = _3;
  return;

}


FlexCAN_IsExCbtEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.8007;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = pBase->CBT;
  _2 = (signed int) _1;
  D.8007 = _2 < 0;
  return D.8007;

}


FlexCAN_GetFDTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->FDCBT;
  _2 = _1 >> 20;
  _3 = _2 & 1023;
  timeSeg->preDivider = _3;
  # DEBUG BEGIN_STMT
  _4 = base->FDCBT;
  _5 = _4 >> 10;
  _6 = _5 & 31;
  timeSeg->propSeg = _6;
  # DEBUG BEGIN_STMT
  _7 = base->FDCBT;
  _8 = _7 >> 5;
  _9 = _8 & 7;
  timeSeg->phaseSeg1 = _9;
  # DEBUG BEGIN_STMT
  _10 = base->FDCBT;
  _11 = _10 & 7;
  timeSeg->phaseSeg2 = _11;
  # DEBUG BEGIN_STMT
  _12 = base->FDCBT;
  _13 = _12 >> 16;
  _14 = _13 & 7;
  timeSeg->rJumpwidth = _14;
  return;

}


FlexCAN_GetTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->CTRL1;
  _2 = _1 >> 24;
  _3 = _2 & 255;
  timeSeg->preDivider = _3;
  # DEBUG BEGIN_STMT
  _4 = base->CTRL1;
  _5 = _4 & 7;
  timeSeg->propSeg = _5;
  # DEBUG BEGIN_STMT
  _6 = base->CTRL1;
  _7 = _6 >> 19;
  _8 = _7 & 7;
  timeSeg->phaseSeg1 = _8;
  # DEBUG BEGIN_STMT
  _9 = base->CTRL1;
  _10 = _9 >> 16;
  _11 = _10 & 7;
  timeSeg->phaseSeg2 = _11;
  # DEBUG BEGIN_STMT
  _12 = base->CTRL1;
  _13 = _12 >> 22;
  _14 = _13 & 3;
  timeSeg->rJumpwidth = _14;
  return;

}


FlexCAN_GetExtendedTimeSegments (const struct FLEXCAN_Type * base, struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->CBT;
  _2 = _1 >> 21;
  _3 = _2 & 1023;
  timeSeg->preDivider = _3;
  # DEBUG BEGIN_STMT
  _4 = base->CBT;
  _5 = _4 >> 10;
  _6 = _5 & 63;
  timeSeg->propSeg = _6;
  # DEBUG BEGIN_STMT
  _7 = base->CBT;
  _8 = _7 >> 5;
  _9 = _8 & 31;
  timeSeg->phaseSeg1 = _9;
  # DEBUG BEGIN_STMT
  _10 = base->CBT;
  _11 = _10 & 31;
  timeSeg->phaseSeg2 = _11;
  # DEBUG BEGIN_STMT
  _12 = base->CBT;
  _13 = _12 >> 16;
  _14 = _13 & 31;
  timeSeg->rJumpwidth = _14;
  return;

}


FlexCAN_SetExtendedTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = timeSeg != 0B;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = base->CBT;
  _3 = _2 & 2147483648;
  base->CBT = _3;
  # DEBUG BEGIN_STMT
  _4 = base->CBT;
  _5 = timeSeg->propSeg;
  _6 = _5 << 10;
  _7 = _6 & 65535;
  _8 = timeSeg->phaseSeg2;
  _9 = _8 & 31;
  _10 = _7 | _9;
  _11 = timeSeg->phaseSeg1;
  _12 = _11 << 5;
  _13 = _12 & 992;
  _14 = _10 | _13;
  _15 = timeSeg->preDivider;
  _16 = _15 << 21;
  _17 = _16 & 2145386496;
  _18 = _14 | _17;
  _19 = timeSeg->rJumpwidth;
  _20 = _19 << 16;
  _21 = _20 & 2031616;
  _22 = _18 | _21;
  _23 = _4 | _22;
  base->CBT = _23;
  return;

}


FlexCAN_SetTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = timeSeg != 0B;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = base->CTRL1;
  _3 = _2 & 65528;
  base->CTRL1 = _3;
  # DEBUG BEGIN_STMT
  _4 = base->CTRL1;
  _5 = timeSeg->propSeg;
  _6 = _5 & 7;
  _7 = timeSeg->phaseSeg2;
  _8 = _7 << 16;
  _9 = _8 & 458752;
  _10 = _6 | _9;
  _11 = timeSeg->phaseSeg1;
  _12 = _11 << 19;
  _13 = _12 & 3670016;
  _14 = _10 | _13;
  _15 = timeSeg->preDivider;
  _16 = _15 << 24;
  _17 = _14 | _16;
  _18 = timeSeg->rJumpwidth;
  _19 = _18 << 22;
  _20 = _19 & 12582912;
  _21 = _17 | _20;
  _22 = _4 | _21;
  base->CTRL1 = _22;
  return;

}


FlexCAN_SetFDTimeSegments (struct FLEXCAN_Type * base, const struct Flexcan_Ip_TimeSegmentType * timeSeg)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = timeSeg != 0B;
  DevAssert (_1);
  # DEBUG BEGIN_STMT
  _2 = base->FDCBT;
  _3 = _2 & 3221783320;
  base->FDCBT = _3;
  # DEBUG BEGIN_STMT
  _4 = base->FDCBT;
  _5 = timeSeg->propSeg;
  _6 = _5 << 10;
  _7 = _6 & 31744;
  _8 = timeSeg->phaseSeg2;
  _9 = _8 & 7;
  _10 = _7 | _9;
  _11 = timeSeg->phaseSeg1;
  _12 = _11 << 5;
  _13 = _12 & 255;
  _14 = _10 | _13;
  _15 = timeSeg->preDivider;
  _16 = _15 << 20;
  _17 = _16 & 1072693248;
  _18 = _14 | _17;
  _19 = timeSeg->rJumpwidth;
  _20 = _19 << 16;
  _21 = _20 & 458752;
  _22 = _18 | _21;
  _23 = _4 | _22;
  base->FDCBT = _23;
  return;

}


FlexCAN_GetBuffStatusImask (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 u32Imask;
  uint8 D.7822;

  <bb 2> :
  # DEBUG BEGIN_STMT
  u32Imask = 0;
  # DEBUG BEGIN_STMT
  if (msgBuffIdx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = base->IMASK1;
  _2 = msgBuffIdx & 31;
  _3 = 1 << _2;
  _4 = _1 & _3;
  _5 = msgBuffIdx & 31;
  u32Imask = _4 >> _5;

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.7822 = (uint8) u32Imask;
  return D.7822;

}


FlexCAN_GetBuffStatusFlag (const struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 flag;
  uint8 D.7663;

  <bb 2> :
  # DEBUG BEGIN_STMT
  flag = 0;
  # DEBUG BEGIN_STMT
  if (msgBuffIdx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = base->IFLAG1;
  _2 = msgBuffIdx & 31;
  _3 = 1 << _2;
  _4 = _1 & _3;
  _5 = msgBuffIdx & 31;
  flag = _4 >> _5;

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.7663 = (uint8) flag;
  return D.7663;

}


FlexCAN_ClearMsgBuffIntStatusFlag (struct FLEXCAN_Type * base, uint32 msgBuffIdx)
{
  uint32 flag;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = msgBuffIdx & 31;
  flag = 1 << _1;
  # DEBUG BEGIN_STMT
  if (msgBuffIdx <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  base->IFLAG1 = flag;

  <bb 4> :
  return;

}


FlexCAN_UnlockRxMsgBuff (const struct FLEXCAN_Type * base)
{
  long unsigned int vol.6;

  <bb 2> :
  # DEBUG BEGIN_STMT
  vol.6 = base->TIMER;
  return;

}


FlexCAN_SetListenOnlyMode (struct FLEXCAN_Type * base, boolean enableListenOnly)
{
  long unsigned int iftmp.7;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->CTRL1;
  _2 = _1 & 4294967287;
  if (enableListenOnly != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.7 = 8;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.7 = 0;

  <bb 5> :
  _3 = iftmp.7 | _2;
  base->CTRL1 = _3;
  return;

}


FlexCAN_SetFDEnabled (struct FLEXCAN_Type * base, boolean enableFD, boolean enableBRS)
{
  long unsigned int iftmp.3;
  long unsigned int iftmp.2;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = base->MCR;
  _2 = _1 & 4294965247;
  if (enableFD != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.2 = 2048;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.2 = 0;

  <bb 5> :
  _3 = iftmp.2 | _2;
  base->MCR = _3;
  # DEBUG BEGIN_STMT
  _4 = base->FDCTRL;
  _5 = _4 & 2147483647;
  if (enableBRS != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  iftmp.3 = 2147483648;
  goto <bb 8>; [INV]

  <bb 7> :
  iftmp.3 = 0;

  <bb 8> :
  _6 = iftmp.3 | _5;
  base->FDCTRL = _6;
  # DEBUG BEGIN_STMT
  _7 = base->FDCTRL;
  _8 = _7 & 4294926591;
  base->FDCTRL = _8;
  return;

}


FlexCAN_IsEnabled (const struct FLEXCAN_Type * pBase)
{
  boolean D.7555;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = pBase->MCR;
  _2 = (signed int) _1;
  D.7555 = _2 >= 0;
  return D.7555;

}


FlexCAN_SetTDCOffset (struct FLEXCAN_Type * base, boolean enable, uint8 offset)
{
  uint32 tmp;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  tmp = base->FDCTRL;
  # DEBUG BEGIN_STMT
  tmp = tmp & 4294926591;
  # DEBUG BEGIN_STMT
  if (enable != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  tmp = tmp | 32768;
  # DEBUG BEGIN_STMT
  _1 = (long unsigned int) offset;
  _2 = _1 << 8;
  _3 = _2 & 7936;
  tmp = tmp | _3;

  <bb 4> :
  # DEBUG BEGIN_STMT
  base->FDCTRL = tmp;
  return;

}


FlexCAN_SetRxFifoGlobalMask (struct FLEXCAN_Type * base, uint32 Mask)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  base->RXFGMASK = Mask;
  return;

}


DevAssert (volatile boolean x)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  x.0_1 = x;
  if (x.0_1 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  return;

}


